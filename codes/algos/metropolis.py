import numpy as np
from typing import Callable, List, Any

class NormalProposal:
    """Proposal distribution that adds normally distributed noise to the current sample."""
    def __init__(self, scale: float):
        self.scale = scale

    def __call__(self, sample: np.ndarray) -> np.ndarray:
        jump = np.random.normal(scale=self.scale, size=sample.shape)
        return sample + jump

class MetropolisSampler:
    """Metropolis-Hastings MCMC sampler."""
    
    def __init__(
        self,
        target: Callable[[np.ndarray], float],
        initial: Callable[[], np.ndarray],
        proposal: Callable[[np.ndarray], np.ndarray],
        iterations: int = 10_000
    ):
        """
        Initialize the Metropolis sampler.
        
        Args:
            target: Target probability density function (unnormalized)
            initial: Function that returns initial sample
            proposal: Function that generates proposals from current sample
            iterations: Number of iterations to run
        """
        self.target = target
        self.initial = initial
        self.proposal = proposal
        self.iterations = iterations
        self.samples = []
        self.acceptance_rate = 0.0  # Track acceptance rate
        self.flop_count = 0  # Track floating point operations
        
    def run(self) -> List[np.ndarray]:
        """Run the Metropolis algorithm and return samples."""
        self.samples = [self.initial()]
        accepted = 0  # Counter for accepted proposals
        self.flop_count = 0  # Reset FLOP counter
        
        for _ in range(self.iterations):
            current = self.samples[-1]
            proposed = self.proposal(current)
            
            # Get target density values and their FLOP counts
            target_current = self.target(current)
            target_flops_current = self.target.get_flop_count()
            
            target_proposed = self.target(proposed)
            target_flops_proposed = self.target.get_flop_count() - target_flops_current
            
            # Add target evaluation FLOPs to total count
            self.flop_count += target_flops_current + target_flops_proposed
            
            # Division for acceptance ratio
            acceptance_ratio = target_proposed / target_current
            self.flop_count += 1  # One division
            
            # Accept or reject (no FLOPs, just comparison)
            if np.random.random() < acceptance_ratio:
                self.samples.append(proposed)
                accepted += 1
            else:
                self.samples.append(current)
        
        # Division for acceptance rate
        self.acceptance_rate = accepted / self.iterations
        self.flop_count += 1  # One division
        
        print(f"Metropolis acceptance rate: {self.acceptance_rate:.2%}")
        return self.samples
    
    def get_samples(self) -> List[np.ndarray]:
        """Get the samples generated by the sampler."""
        return self.samples
    
    def get_acceptance_rate(self) -> float:
        """Get the acceptance rate from the last run."""
        return self.acceptance_rate
        
    def get_flop_count(self) -> int:
        """Get the total number of floating point operations performed during sampling."""
        return self.flop_count
